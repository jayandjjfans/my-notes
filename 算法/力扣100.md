#### 一、逻辑性强

##### 1.[接雨水](https://leetcode.cn/problems/trapping-rain-water/)

每一列能够接到的雨水取决于左右最大值中小的部分与当前列的差值。双指针，分别维护左边最大值和右边最大值；当哪边相对小时，此边成为雨水数量的瓶颈，并移动它，然后雨水数量累加。例如：当右侧最大值大于左侧最大值时，能够接到的雨水水量取决于左侧，所以移动左侧，移动右侧没意义。左右指针移动时，只有某列被更新为最大值时，此时雨水数量为0。

双指针的合理性不太好理解，相对容易理解的是，遍历两次数组，记录某索引处的左右最大值去计算。

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}
```

##### 4.[乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

思路一：以索引i处结尾的乘积最大值/最小值=Math.max/min(max(i-1)*nums[i],min(i-1)*nums[i],nums[i])

```java
//思路二：其实等价于思路一。
//imax/imin维护的的就是索引i结尾的最大值/最小值
//以imax为例：如果nums[i]是负数，若要获得以i结尾的乘积最大值那我们希望它乘以i-1结尾的最小值，反之同理
//所以我们需要提前置换imax/imin
class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for(int i=0; i<nums.length; i++){
            if(nums[i] < 0){ 
              int tmp = imax;
              imax = imin;
              imin = tmp;
            }
            imax = Math.max(imax*nums[i], nums[i]);
            imin = Math.min(imin*nums[i], nums[i]);
            
            max = Math.max(max, imax);
        }
        return max;
    }
}
```

##### 5.[下一个排列](https://leetcode.cn/problems/next-permutation/)

从后向前查找第一对相邻的升序arr[i]<arr[j],此时（j,end）一定是降序

（j,end）从后向前找第一个大于arr[i]的arr[k]，交换i和k,此时（j,end）依然降序，然后升序排列；

若第一步未找到，则初始数组全部降序，直接升序排列

##### 11.[二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

递归地处理左右子树，处理时更新子树的路径和并返回该节点的贡献。

```java
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
      //该方法返回的是该（子）节点的最大贡献值
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node.val + leftGain + rightGain;

        // 更新答案
        maxSum = Math.max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node.val + Math.max(leftGain, rightGain);
    }
}

```

##### 20.[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

若某根节点为结果值，则它的左右子树都能找到p或q；如果左右子树有一个值为空，则递归地处理另一个子树。

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //可以理解为在寻找p或者q，只要找到一个就有办法做出判断
        if(root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        /*在左右子树找p或者q，有以下几种情况：
      	1.左右子树都包含1个节点，则结果为此root；
      	2.某个子树不包含，则把另一个子树的查找结果返回即可：无论是否为null，都有办法做出判断
      	*/
        if(left == null) return right;
        if(right == null) return left;
      	//如果左右子树都包含p或者q，则此root为结果值
        return root;
    }
}
```

##### 21.[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

注意实现栈的API：ArrayDeque#peekLas/pollLast/addLast

```java
//遍历过程中需要维护一个单调递增栈。
//1、若当前位置高度若小于栈顶高度，说明栈顶值对应高度形成的矩形最大值可以确定下来了，弹出并更新最大值；
//2、将栈顶所有符合条件的值弹出并一一计算和更新最大值，直到栈顶元素对应高度小于当前高度。
//3、将当前元素加入栈中。
//4、最终形成一个单调递增栈，栈中留下的都是没有比它高度更低的元素。
//5、这些元素计算最大矩形时，依次出栈，长度最右侧是数组末尾，最左侧则是栈顶的位置（栈顶位置高度小于它）
class Solution {
    public int largestRectangleArea(int[] heights) {
        if (heights.length==0) return 0;
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        int res=0;
        for (int i = 0; i < heights.length; i++) {
            while(!stack.isEmpty()&&heights[stack.peekLast()]>heights[i]){
                int curHeight=heights[stack.pollLast()];
                while(!stack.isEmpty()&&heights[stack.peekLast()]==curHeight){
                    stack.pollLast();
                }
                res=Math.max(res,curHeight*(stack.isEmpty()?i:i-stack.peekLast()-1));
            }
            stack.addLast(i);
        }
        while(!stack.isEmpty()){
            int curHeight=heights[stack.pollLast()];
            while(!stack.isEmpty()&&heights[stack.peekLast()]==curHeight){
                stack.pollLast();
            }
            res=Math.max(res,curHeight*(stack.isEmpty()?heights.length:heights.length-stack.peekLast()-1));
        }
        return res;
    }
}
```

##### 28.[N 皇后](https://leetcode.cn/problems/n-queens/)

```Java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        //记录第n行放皇后的位置
        int[] col = new int[n];
        //记录第n列是否有皇后
        boolean[] onPath = new boolean[n];
       //记录副对角线是否放置皇后（同一个副对角线行索引+列索引相等）
        boolean[] diag1 = new boolean[n * 2 - 1];
       //记录主对角线是否放置皇后（同一个副对角线行索引-列索引相等）
        boolean[] diag2 = new boolean[n * 2 - 1];
        dfs(0, n, col, onPath, diag1, diag2, ans);
        return ans;
    }

    private void dfs(int r, int n, int[] col, boolean[] onPath, boolean[] diag1, boolean[] diag2, List<List<String>> ans) {
        if (r == n) {
            List<String> board = new ArrayList<>(n);
            for (int c : col) {
                char[] row = new char[n];
                Arrays.fill(row, '.');
                row[c] = 'Q';
                board.add(new String(row));
            }
            ans.add(board);
            return;
        }
        for (int c = 0; c < n; c++) {
            int rc = r - c + n - 1;
            if (!onPath[c] && !diag1[r + c] && !diag2[rc]) {
                col[r] = c;
                onPath[c] = diag1[r + c] = diag2[rc] = true;
                dfs(r + 1, n, col, onPath, diag1, diag2, ans);
                onPath[c] = diag1[r + c] = diag2[rc] = false; // 恢复现场
            }
        }
    }
}

```

##### 17.[最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

```java
 //自己曾经同样的思路独立做出来过。这个是优化后的代码。
public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int res = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = i - 2 > 0 ? dp[i - 2] + 2 : 2;
                } else {
                  //此处s.charAt(i - dp[i - 1] - 1) == '('的条件，包含着dp[i - 1]!=0的意思
                    if (i - 1 - dp[i - 1] >= 0 && s.charAt(i - 1 - dp[i - 1]) == '(') {
                        dp[i] = dp[i - 1] + 2;
                        if (i - dp[i] >= 0) {
                            dp[i] = dp[i] + dp[i - dp[i]];
                        }
                    }
                }
                res = Math.max(res, dp[i]);
            }
        }
        return res;
    }
```



##### 26.[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

```Java
class Solution {
    public int findMin(int[] nums) {
        int len = nums.length;
        int l = 0;
        int r = nums.length - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            //升序曲线图情况一共有四种，1左长右短、2左短右长、3左右相等、4全局升序
            //只有第1、3情况，最小值在mid的右侧；其余则在左侧或mid处
            //若为1、3情况，则以下判断成立
            if (nums[mid] > nums[r]) l = mid + 1;
            else r = mid;
        }
        return nums[l];
    }
}
```

##### 24.[搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

此题分析思路同上：

1. 升序曲线图情况一共有四种，1左长右短、2左短右长、3左右相等、4全局升序
2. 通过比较nums[left] 和nums[mid]的大小关系，可以先将前三种情况和最后一种区分开
3. 对于nums[left] <= nums[mid]，可通过target是否在left和mid之间再次区分；对于nums[0] > nums[mid]，可通过target是否在mid和right之间再次区分

```java
    public int search(int[] nums, int target) {
        int l=0;
        int r=nums.length-1;
        while(l<=r){
            int mid=(l+r)/2;
            if (nums[mid]==target) return mid;
            if (nums[mid]>=nums[l]){
                if (target>=nums[l]&&target<nums[mid]){
                    r=mid-1;
                }else{
                    l=mid+1;
                }
            }else{
                if (target>nums[mid]&&target<=nums[r]){
                    l=mid+1;
                }else{
                    r=mid-1;
                }
            }
        }
        return -1;
    }
```

##### 30.[寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

```java
 //此题的思路是在较短的数组上进行二分查找一个分界线，通过分界线两侧的数字确定中位数
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
       //此处的目的是为了在长度更短的数组上去二分查找。如果在较长的数组进行二分，较短数组的下标可能会越界
        if (nums2.length<nums1.length){
            int[] temp=nums1;
            nums1=nums2;
            nums2=temp;
        }
        int m=nums1.length;
        int n=nums2.length;
        //定义分割线左侧的数量大于（总数量为奇数）或者等于（偶数）右侧数量
        int totalLeft=(m+n+1)/2;

        int l=0;
       //此处r为什么等于m？我们定义i、j为分割线右侧的第一个索引，所以i有可能是超出索引范围的，即较短数组都          在分割线左侧
        int r=m;
        while(l<r){
            //若i为分割线右侧的第一个索引，则分割线左侧的短数组数量即为i，长数组数量j可以计算得出
            int i=(l+r+1)/2;
            int j=totalLeft-i;
            //最终的分割线位置一定符合以下条件：nums1[i-1]<=nums2[j]或者nums2[j-1]<=nums1[i]
            if (nums1[i-1]>nums2[j]){
              //表示当前分割线需要左移
                r=i-1;
            }else{
              //分割线在右侧，包含当前位置
                l=i;
            }
        }
        int i= l;
        int j=totalLeft-i;

        int nums1Left=i==0?Integer.MIN_VALUE:nums1[i-1];
        int nums2Left=j==0?Integer.MIN_VALUE:nums2[j-1];
        int nums1Right=i==m?Integer.MAX_VALUE:nums1[i];
        int nums2Right=j==n?Integer.MAX_VALUE:nums2[j];


        if ((m+n)%2==1){
            return Math.max(nums1Left,nums2Left);
        }else{
            return (Math.max(nums1Left,nums2Left)+Math.min(nums1Right,nums2Right))/2.0;
        }
    }
```

##### 16.[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

用单调递减队列（LinkedList）维护数组元素索引。当前窗口赋最大值时需要先判断当前队首（最大值）是否超出窗口范围并且移除。

```Java
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] res = new int[nums.length - k + 1];
        LinkedList<Integer> stack = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            while (!stack.isEmpty()&&nums[i]>=nums[stack.peekLast()]){
                stack.removeLast();
            }
            stack.add(i);
            if (stack.peekFirst()==i-k){
                stack.removeFirst();
            }
            if (i>=k-1){
                res[i+1-k]=nums[stack.peekFirst()];
            }
        }
        return res;
    }
```

##### 26.[课程表](https://leetcode.cn/problems/course-schedule/)

```Java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //定义入度数组，索引处（课程号）对应入度，比如课程0的入度为0        
        int[] inDegree = new int[numCourses];  
        //定义map数组，key课程号，value：依赖key的课程号，比如key为1，依赖的value为3，4
        Map<Integer,List<Integer>> map = new HashMap<>();
        for(int i = 0; i < prerequisites.length;i++){
        //遍历依赖关系表；在入度数组对应索引处++
            inDegree[prerequisites[i][0]]++;      
       //没有对map初始化，这里对map初始化一个list数组，存放依赖的课程
            map.putIfAbsent(prerequisites[i][1],new ArrayList<>());
       //在对应被依赖课程key处添加依赖key的课程
            map.get(prerequisites[i][1]).add(prerequisites[i][0]);
        }
       //新建列表，把入度为0的课放进来
        Queue<Integer> que = new LinkedList<>();
        for(int i = 0 ; i <inDegree.length;i++){
            if(inDegree[i]==0){
                que.offer(i);
            }
        }

        while(!que.isEmpty()){
           //弹出已选课程，在map找到依赖它的课程，在入度数组--
            int course = que.poll();
            numCourses--;
            for(int nextCourse : map.getOrDefault(course,new ArrayList<>())){
                if(--inDegree[nextCourse]==0){
                    que.offer(nextCourse);
                }
            }
        }
        return numCourses==0;
    }
}
```

##### 

#### 二.技巧+细节

##### 2.[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

一句话总结思路：用哈希表记录每个字符的索引，遍历时若哈希表包含字符则更新此字符索引并更新子串起始点

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len=s.length();
        int res=0;
        Map<Character,Integer> map=new HashMap<>();
        for(int i=0,start=0;i<len;i++){
            char element=s.charAt(i);
            if(map.containsKey(element)){
             start=Math.max(start,map.get(element)+1);
            }
          //即使更新了左指针也要更新该字符的最新索引
            map.put(element,i);
            res=Math.max(res,i-start+1);
        }
        return res;
  
    }
}
```



##### 6.[寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int len = nums.length; // n + 1 = len, n = len - 1
        // 在 [1..n] 查找 nums 中重复的元素
        int left = 1;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            int count = 0;
            for (int num : nums) {
                 //关于为何统计小于等于mid，因为假如该数量大于mid的值，则重复元素一定位于mid左边（包含mid）
                if (num <= mid) {
                    count++;
                }
            }
            if (count > mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

##### 7.[缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

```java
//自己做出来的！
class Solution {
    public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            //若当前位置元素与索引不匹配，尝试放到正确的位置
            while(nums[i]!=i+1){
                //若超出长度或者小于0或者
                //正确位置已存在正确值！！！
                if (nums[i]>nums.length||nums[i]<=0||
                nums[nums[i]-1]==nums[i]) break;
                int temp=nums[nums[i]-1];
                nums[nums[i]-1]=nums[i];
                nums[i]=temp;
            }
        }
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]!=i+1) return i+1;
        }
        return nums.length+1;
    }
}
```

##### 8.[跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        int length = nums.length;
        int end = 0;
        int maxPosition = 0; 
        int steps = 0;
      //如果在n-2都没达到“上一步所跨过的区域”所能达到的最远处，说明最远处至少在n-1位置，不需要再增加步数了
        for (int i = 0; i < length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            if (i == end) {
              //当追上时，说明达到了“上一步所跨过的区域”所能达到的最远处
                end = maxPosition;
                steps++;
            }
        }
        return steps;
    }
}
```

##### 9.[零钱兑换](https://leetcode.cn/problems/coin-change/)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        for (int i = 1; i <=amount; i++) {
            dp[i]=-1;
            for (int j = 0; j < coins.length; j++) {
                if (i-coins[j]>=0&&dp[i-coins[j]]!=-1){
                    dp[i]=dp[i]==-1?dp[i-coins[j]]+1:Math.min(dp[i],dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount];
    }
}
```



##### 10.[路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

可以借鉴“和为K的子数组”的思路

##### 12.[三数之和](https://leetcode.cn/problems/3sum/)

```java
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        ArrayList<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
          //注意不要漏掉0
            if (nums[i] <= 0) {
                //需要去除重复，并不会漏掉，因为该位置能找到的，它前一个元素也可以
                if (i - 1 >= 0 && nums[i] == nums[i - 1]) continue;
                  int l = i + 1;
                  int r = nums.length - 1;
                  while (l < r) {
                     if (nums[l] + nums[r] + nums[i]==0) {
                         res.add(Arrays.asList(nums[i], nums[l], nums[r]));
                      //过滤掉重复结果，牢记这一行的技巧：当左指针右移后与前一个不相等则会跳出循环
                         while (l < r && nums[l] == nums[++l]) ;
                    } else if (nums[l] + nums[r]+ nums[i]>0) {
                        r--;
                    } else {
                        l++;
                    }
                }
            }
        }
        return res;
    }
```



##### 13.[LRU 缓存](https://leetcode.cn/problems/lru-cache/)

双向链表+哈希表：初始化时构造伪头部和伪尾部，方便寻找首尾

新添加进来的节点，只需要addToHead；put和get存在的节点，必须要先removeNode，然后addToHead

```java
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }
```

##### 3.[找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) 

遍历p的长度，用数组记录s和p的元素的个数，s包含则该元素++，p包含则该元素--

然后遍历数组记录数量不同元素的个数differ（若differ=0，则返回值添加index=0）

遍历s，维护滑动窗口，根据窗口头和尾的元素个数的值（0或1）修改differ，并同时维护数组元素的个数；若differ=0，则返回值添加index=i+1

```java
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<Integer>();
        if (s.length() < p.length()) return res;
        int[] count = new int[26];
        int len = p.length();
        for (int i = 0; i < len; i++) {
            count[p.charAt(i) - 'a']++;
            count[s.charAt(i) - 'a']--;
        }
        int diff = 0;
        for (int i = 0; i < 26; i++) {
            if (count[i] != 0) {
                diff++;
            }
        }
        if (diff == 0) {
            res.add(0);
        }
        for (int i = 1; i <= s.length() - p.length(); i++) {
            count[s.charAt(i - 1) - 'a']++;
            if (count[s.charAt(i - 1) - 'a'] == 0) {
                diff--;
            } else if (count[s.charAt(i - 1) - 'a'] == 1) {
                diff++;
            }
            ;
            count[s.charAt(i + len - 1) - 'a']--;
            if (count[s.charAt(i + len - 1) - 'a'] == 0) {
                diff--;
            } else if (count[s.charAt(i + len - 1) - 'a'] == -1) {
                diff++;
            }
            if (diff == 0) res.add(i);

        }
        return res;
    }
}
```

##### 15.[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

和找所有字母异位词类似，但是有区别：

此题字符串中的字符大小写都有，所以只能设置128长度数组；

此题中的滑动窗口大小是不固定的，窗口是先扩大找到符合条件然后收缩并不断更新结果

```Java
//滑动窗口一般模板
int left = 0, right = 0;
while (right < s.length()) {
    // 增大窗口
    window.add(s[right]);
    right++;

    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

```java
class Solution {
    public String minWindow(String S, String t) {
        char[] s = S.toCharArray();
        int m = s.length;
        int ansLeft = -1;
        int ansRight = m;
        int left = 0;
        int less = 0;
        int[] cntS = new int[128]; 
        int[] cntT = new int[128]; 
        for (char c : t.toCharArray()) {
            if (cntT[c]++ == 0) {
                //less代表窗口中缺少的字符的种类数
                less++; 
            }
        }
        for (int right = 0; right < m; right++) {
            char c = s[right]; 
            if (++cntS[c] == cntT[c]) {
                less--; 
            }
            while (less == 0) { 
                if (right - left < ansRight - ansLeft) {
                    ansLeft = left; 
                    ansRight = right;
                }
                char x = s[left++]; 
                if (cntS[x]-- == cntT[x]) {
                    less++; 
                }
            }
        }
                                                     
        return ansLeft < 0 ? "" : S.substring(ansLeft, ansRight + 1);
    }
}
```



##### 18.[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```Java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0;
        ArrayList<Integer> res = new ArrayList<>();
        while (true) {
            for (int i = l; i <= r; i++) res.add(matrix[t][i]); 
            if (++t > b) break;
            for (int i = t; i <= b; i++) res.add(matrix[i][r]); 
            if (l > --r) break;
            for (int i = r; i >= l; i--) res.add(matrix[b][i]); 
            if (t > --b) break;
            for (int i = b; i >= t; i--) res.add(matrix[i][l]); 
            if (++l > r) break;
        }
        return res;
    }
}
```

##### 19.[编辑距离](https://leetcode.cn/problems/edit-distance/)

1. dp[i][j]表示word1前i个字符转换成word2前j个字符的最小次数，首先初始化dp[i][0]和dp[0][j]
2. 若word1[i]==word2[j]，则dp[i][j]= dp[i -1][j -1]；否则，则考虑替换&&删除&&新增三种场景

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int n1 = word1.length();
        int n2 = word2.length();
        int[][] dp = new int[n1 + 1][n2 + 1];
        // 第一行
        for (int j = 1; j <= n2; j++) dp[0][j] = dp[0][j - 1] + 1;
        // 第一列
        for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;

        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
                else dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }
        }
        return dp[n1][n2];  
    }
}
```

##### 22.[合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```Java
class Solution {
   //方法一：使用优先级队列PriorityQueue，构造器入参实现compare方法
   public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        PriorityQueue<ListNode> queue = new PriorityQueue<>(lists.length, new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                if (o1.val < o2.val) return -1;
                else if (o1.val == o2.val) return 0;
                else return 1;
            }
        });
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;
         //此时queue里是链表头节点排序后的
        for (ListNode node : lists) {
            if (node != null) queue.add(node);
        }
        while (!queue.isEmpty()) {
         //取出最小值后将该节点下一个节点加入排序
            p.next = queue.poll();
            p = p.next;
            if (p.next != null) queue.add(p.next);
        }
        return dummy.next;
    }
}
   

    //方法二：分治两两合并
   public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }
    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left == right) return lists[left];
        int mid = left + (right - left) / 2;
        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);
        return mergeTwoLists(l1, l2);
    }

    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }
```

##### 23.[每日温度](https://leetcode.cn/problems/daily-temperatures/)

遍历数组，栈保存索引，维持一个单调递减栈，若当前索引值大于栈顶索引值，索引相减即得到结果。

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        int[] res = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            while(!deque.isEmpty()&&temperatures[i]>temperatures[deque.peekLast()]){
                Integer pop = deque.pollLast();
                res[pop]=i-pop;
            }
            deque.addLast(i);
        }
        return res;
    }
}
```

##### 25.[排序链表](https://leetcode.cn/problems/sort-list/)

```java
public ListNode sortList(ListNode head) {
        if (head==null||head.next==null) return head;
        ListNode slow=head;
  			//切记此处fast不能赋值为head！！！否则当链表为两个节点时就无法拆分开
        ListNode fast=head.next;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        ListNode temp=slow.next;
        slow.next=null;
  			//此处必须将返回值进行merge（head和temp可能排序后并不是头节点）
        ListNode a=sortList(head);
        ListNode b=sortList(temp);
        return mergeList(a,b);
    }
```



##### 27.[实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

可以这样去理解这个数据结构：

第一层有26个节点，代表26个字母，节点有可能为空；每个节点也都有26个子节点，以此类推。

```java
class Trie {
    Trie[] child;
    boolean isEnd;

    public Trie() {
        child=new Trie[26];
        isEnd=false;
    }

    public void insert(String word) {
        Trie node=this;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            int index=c-'a';
            if (node.child[index]==null){
                node.child[index]=new Trie();
            }
            node=node.child[index];
        }
        node.isEnd=true;
    }

    public boolean search(String word) {
        Trie trie = searchPre(word);
        return trie !=null&&trie.isEnd;
    }

    public boolean startsWith(String prefix) {
        return searchPre(prefix)!=null;
    }
    
    public Trie searchPre(String str){
        Trie node=this;
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (node.child[c-'a']==null){
                return null;
            }
            node=node.child[c-'a'];
        }
        return node;
    }
}

```



##### 29.[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```java
   //先二分查找到目标值，然后分别查找前后位置
    l = 0;
    r = mid;
    while (l < r) {
        if (nums[l] == target) break;
        int mid1 = (l + r) / 2;
        if (nums[mid1] < target) {
            l = mid1 + 1;
        } else {
            r = mid1;
        }
    }
    int res1 = l;

    l = mid;
    r = nums.length - 1;
    while (l < r) {
        if (nums[r] == target) break;
       //重点关注这里的技巧！！！
        int mid1 = (l + r + 1) / 2 ;
        if (nums[mid1] > target) {
            r = mid1 - 1;
        } else {
            l = mid1;
        }
    }
    int res2=r;
```

##### 31.[盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

左右双指针，每次移动较短的线，并更新最大值

##### 32.[最小栈](https://leetcode.cn/problems/min-stack/)

##### 33.[字符串解码](https://leetcode.cn/problems/decode-string/)

```java
    int index=0;
    public String decodeString(String s) {
        StringBuilder res = new StringBuilder();
        int len=s.length()-1;
        int count=0;
        while(index<=len){
            if (Character.isLetter(s.charAt(index))){
                res.append(s.charAt(index));
                index++;
            }else if (Character.isDigit(s.charAt(index))){
                count=count*10+(s.charAt(index)-'0');
                index++;
            }else if (s.charAt(index)=='['){
                index++;
                String str = decodeString(s);
                res.append(str.repeat(count));
            }else{
                index++;
                return res.toString();
            }
        }
        return res.toString();
    }
```



##### 34.[数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

```java
class MedianFinder {
    Queue<Integer> A, B;
    public MedianFinder() {
        A = new PriorityQueue<>(); // 小顶堆，保存较大的一半
        B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半
    }
    public void addNum(int num) {
        if (A.size() != B.size()) {
            A.add(num);
            B.add(A.poll());
        } else {
            B.add(num);
            A.add(B.poll());
        }
    }
    public double findMedian() {
        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
    }
}

```



##### 30.[颜色分类](https://leetcode.cn/problems/sort-colors/)

用两个指针zero/two分别指向可以放0和2的索引处，i遍历数组遇到0或者2则对应地交换位置且挪动指针，遇到1则i++。当i>two时，遍历结束。

```java
        while(i<=r){
            if (nums[i]==0){
                swap(nums,l,i);
              //因为遍历从前往后，所以此时交换后i处肯定是1，需要i++
                i++;
                l++;
            }else if(nums[i]==1){
                i++;
            }else{
                swap(nums,r,i);
              //此处不需要i++,因为交换后i处可能是0或2
                r--;
            }
        }
```

#### 三、技巧

##### 1.[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

第二次遍历时选择遍历已保存全部数值的set而不是原始nums，set去重效率更高；

还有个其他优化点：例如当此时最大长度超过数组一半时即可结束

##### 2.[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

##### 3.[和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

##### 4.[买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

遍历数组维护一个最小值，用当前值-最小值=盈利值，不断更新盈利值的最大值

##### 5.[买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

加和数组中所有的上升趋势

##### 6.[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```
dp[i]=Math.max(dp[j].....)+1 (nums[j]<nums[i])
返回值=Math.max(dp[i]....)
```

##### 7.[最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

参考***分割回文串***

##### 8.[多数元素](https://leetcode.cn/problems/majority-element/)

##### 9.[除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

从数组头、尾遍历两次，从头遍历时answer[i]=i-1个数字的乘积，从尾遍历时answer[i]=answer[i]*（i-1）个数字的乘积

##### 10.[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

快慢指针相遇后，一个指针a重新从head走，slow从相遇点走，当a走到入环处时，slow正好走到入环处。

##### 11.[轮转数组](https://leetcode.cn/problems/rotate-array/)

```java
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
```

##### 12.[跳跃游戏](https://leetcode.cn/problems/jump-game/)

遍历数组，试探当前所能触达的最远处（修路）；假如到达某节点，路还没修过来，则无法到达此处和终点

##### 13.[移动零](https://leetcode.cn/problems/move-zeroes/)

left指向数组未被占用的位置，right!=0则交换；被交换的要么是0，要么是原地交换

##### 14.[随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

##### 15.[单词搜索](https://leetcode.cn/problems/word-search/)

```Java
    private boolean search(char[][] board, int i, int j, String word, int index) {
        if (index == word.length()) return true;
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(index))
            return false;
        //预防走回头路找到符合的字符
        board[i][j] = '0';
        if (search(board, i + 1, j, word, index + 1) ||
                search(board, i - 1, j, word, index + 1) ||
                search(board, i, j + 1, word, index + 1) ||
                search(board, i, j - 1, word, index + 1)) {
            return true;
        }
        board[i][j] = word.charAt(index);
        return false;
    }
```



##### 16.[分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

先预处理用二维数组存储子字符串是否为回文再进行回溯。预处理时从字符串末尾向前遍历，而不是从前向后。这样可以达到中心扩展的效果。

```Java
class Solution {
    boolean[][] f;
    List<List<String>> ret = new ArrayList<List<String>>();
    List<String> ans = new ArrayList<String>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new boolean[n][n];
        for (int i = 0; i < n; ++i) {
            Arrays.fill(f[i], true);
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
              //这一行很妙
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ret;
    }

    public void dfs(String s, int i) {
        if (i == n) {
            ret.add(new ArrayList<String>(ans));
            return;
        }
        for (int j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                ans.remove(ans.size() - 1);
            }
        }
    }
}
```



##### 17.[岛屿数量](https://leetcode.cn/problems/number-of-islands/)

第一反应可能会创建个布尔数组记录当前是否搜索过；可以通过修改原数组的值（1改成2）来达到同样效果

##### 18.[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

快指针每走到K位置节点处，然后翻转链表，头节点递归地指向下一次翻转函数，入参为K.next

```java
 //注意翻转链表的写法
private void reverse(ListNode head, int k) {
        ListNode m=head;
        ListNode n=head.next;
        ListNode l;
        while(k!=1){
            l=m;
            m=n;
            n=n.next;
            m.next=l;
            k--;
        }
    }
```

##### 19.[最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

```Java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int len1=text1.length();
        int len2=text2.length();
        //初始化多出来一个元素可以避免初始化0索引的值
        int[][] dp = new int[len1+1][len2+1];
        
        for (int i = 1; i <=len1; i++) {
            for (int j = 1; j <=len2; j++) {
                if (text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```

##### 20.[单词拆分](https://leetcode.cn/problems/word-break/)

```Java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0]=true;
        HashSet<String> set = new HashSet<>(wordDict);
        for (int i = 1; i <=s.length() ; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && set.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

##### 21.[划分字母区间](https://leetcode.cn/problems/partition-labels/)

用map保存每个字母的最后位置；遍历字符串，获取该字符的最远位置，不断更新当前区间的最远处，若最远处即是此i位置，则加入区间（i-left）。然后更新起始位置=i+1。（类似于跳跃游戏）

```Java
class Solution {
    public List<Integer> partitionLabels(String s) {
        ArrayList<Integer> res = new ArrayList<>();
        char[] array = s.toCharArray();
        HashMap<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < array.length; i++) {
            map.put(array[i],i);
        }

        int left=0;
        int current=Integer.MIN_VALUE;
        for (int i = 0; i < array.length; i++) {
            current=Math.max(current,map.get(array[i]));
            if (i==current){
                res.add(current-left+1);
                left=i+1;
            }
        }
        return res;
    }
}
```

##### 22.[字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> m = new HashMap<>();
        for (String s : strs) {
            // 把 s 排序，作为哈希表的 key
            char[] sortedS = s.toCharArray();
            Arrays.sort(sortedS);
            // 排序后相同的字符串分到同一组
            // computeIfAbsent：如果 key 不在哈希表中，则插入一个新的 ArrayList
            m.computeIfAbsent(new String(sortedS), _ -> new ArrayList<>()).add(s);
        }
        // 哈希表的 value 保存分组后的结果
        return new ArrayList<>(m.values()); 
    }
}

```



##### 24.[括号生成](https://leetcode.cn/problems/generate-parentheses/)

目标字符串要保证截止到某个索引，右括号数量要小于左括号；然后给该字符串填充字符，每个索引都可以放左括号和右括号（左括号数量大于右括号时）。递归地填充下一个索引处直到左右括号数量等于目标值

##### 25.[旋转图像](https://leetcode.cn/problems/rotate-image/)

```Java
//方法一：听说很多面试官让用这种方法写
//如何记忆这种解法：1、首先我们可以看到，该方法一次循环中是交换四个元素，这是由“四条边”决定的；
//               2、其次是两层循环，循环结束条件n / 2和(n + 1) / 2是可以互换的
//                3、给四个元素赋值时，i、j位置也是一直在互换的；并且可以用（0，0）位置的那组四个元素  //                  来敲定n-1所在的位置
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
   

//方法二
				// 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
            }
        }
```

##### 27.[矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

开辟俩数组，分别记录某行或者某列是否有0；然后遍历矩阵根据数组置0

用矩阵第一行第一列记录某行某列是否有0，用俩布尔变量记录第一行/列是否有0；然后遍历矩阵/首行/首列置0

用矩阵第一行第一列记录某行某列是否有0，用matrix[0][0]记录首行是否为零，只用一个布尔变量记录第一列是否有0；置0时要从最后一行处理，并同时根据布尔变量处理首列。倒序是为了避免matrix[0][0]=0的情况下，第一行提前全被置0影响下面元素的判断。

##### 28.[数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

1.快速选择

2.使用优先队列小根堆，先放进去前K个元素；然后遍历剩余元素，若大于堆顶（堆顶值最小）则poll然后offer；最后返回堆顶即为第K大

##### 29.[前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

同上题思路一样，只不过构造优先队列时可用以下写法，则小根堆只保存高频数字即可。

```java
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }
        });
```

##### 31.[相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

a和b分别从头节点向后移动，到null后从另一个头节点开始；他们相等时要么为相交点要么都为链表尾null。特殊情况为：两条链表长度相等，若有交点则提前相等，不会转到另一个头节点

```Java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A = headA, B = headB;
        while (A != B) {
          	//注意：两个指针一定要走到null的位置，否则不相交的两个链表无法跳出循环！
            A = A != null ? A.next : headB;
            B = B != null ? B.next : headA;
        }
        return A;
    }
}
```

##### 32.[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```Java
class Solution {
//首先按照先序遍历的顺序依次去构造节点，但是根结点是否有左子树或右子树，取决于中序遍历中根结点的值左侧或者右侧是否有元素；
//查找中序遍历中当前根结点左侧或者右侧是否有元素；提前用map保存中序遍历值与索引的映射，快速定位到根结点位置；
    int index = 0;
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return dg(preorder, inorder, 0, inorder.length - 1);
    }

    private TreeNode dg(int[] preorder, int[] inorder, int start, int end) {
        if (start > end) return null;
        TreeNode node = new TreeNode(preorder[index++]);
        int target = map.get(node.val);
        node.left = dg(preorder, inorder, start, target - 1);
        node.right = dg(preorder, inorder, target + 1, end);
        return node;
    }
}
```

##### 33.[合并区间](https://leetcode.cn/problems/merge-intervals/)

```Java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (p, q) -> p[0] - q[0]);
        ArrayList<int[]> list = new ArrayList<>();
         ..................................
        return list.toArray(new int[list.size()][]);
    }
}
```

##### 34.[二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

##### 35.[二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

##### 36.[将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

##### 37.[二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

##### 38.[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

##### 39.[组合总和](https://leetcode.cn/problems/combination-sum/)

##### 40.[搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

```Java
//方法一  
public boolean searchMatrix(int[][] matrix, int target) {
        int l1= matrix.length-1;
        int l2=matrix[0].length-1;

        int l=0;
        while(l<l1){
          //关注此处的技巧！！
            int mid=(l+l1+1)/2;
            if (matrix[mid][0]==target) return true;
            if (matrix[mid][0]<target) l=mid;
            if (matrix[mid][0]>target) l1=mid-1;
        }
        l=0;
        while(l<=l2){
            int mid=(l+l2)/2;
            if (matrix[l1][mid]==target) return true;
            if (matrix[l1][mid]>target) l2=mid-1;
            if (matrix[l1][mid]<target) l=mid+1;
        }
        return false;
    }

//方法二  同下面题
```

##### 23.[搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

从矩阵右上角开始搜索，大于目标值则左移动，否则下移动，直到找到目标值或者超出矩阵范围

##### 41.[完全平方数](https://leetcode.cn/problems/perfect-squares/)

```java
class Solution {
    public int numSquares(int n) {
        int[] f = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int minn = Integer.MAX_VALUE;
          //注意此处的循环方式
            for (int j = 1; j * j <= i; j++) {
                minn = Math.min(minn, f[i - j * j]);
            }
            f[i] = minn + 1;
        }
        return f[n];
    }
}
```





##### 42.[分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

考虑二维数组，dp[i][j]的含义为前i个数字可否拼成j，二维数组横向是0~target，纵向是num[0]~num[len-1]。

dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]  (dp[0][0]=true)  

进阶1：每一行只参考上一行的值，所以可以只有两个一维数组；

进阶2:**当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值**。因此，我们可以只开一个一维数组，从后向前依次填表即可。如果一维数组从前往后填表，会覆盖上一行的值无法参考。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return false;
        }
        int sum = 0, maxNum = 0;
        for (int num : nums) {
            sum += num;
            maxNum = Math.max(maxNum, num);
        }
        if (sum % 2 != 0) {
            return false;
        }
        int target = sum / 2;
        if (maxNum > target) {
            return false;
        }
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;
        for (int i = 0; i < n; i++) {
            for (int j = target; j >= nums[i]; --j) {
                dp[j] |= dp[j - nums[i]];
                if (dp[target]) return true;
            }
        }
        return false;
    }
}
```

##### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

#### 四、送分题

##### 1.[合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

##### 2.[回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

快慢指针，慢指针反转链表；快指针到达终点后开始从中点两侧比较

还有种递归算法，很骚。

##### 3.[两数之和](https://leetcode.cn/problems/two-sum/)

##### 4.[反转链表](https://leetcode.cn/problems/reverse-linked-list/)

##### 5.[环形链表](https://leetcode.cn/problems/linked-list-cycle/)

##### 6.[两数相加](https://leetcode.cn/problems/add-two-numbers/)

##### 7.[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

##### 8.[两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

##### 9.[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

##### 10.[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

##### 11.[翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

##### 12.[对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

##### 13.[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```java
    Integer min = null;
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        boolean bst = isValidBST(root.left);
        if (!bst) return false;
        if (min != null && root.val <= min) {
            return false;
        }
        min = root.val;
        return isValidBST(root.right);
    }
```



##### 14.[二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

##### 15.[全排列](https://leetcode.cn/problems/permutations/)

##### 16.[子集](https://leetcode.cn/problems/subsets/)

##### 17.[搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

##### 18.[有效的括号](https://leetcode.cn/problems/valid-parentheses/)

##### 19.[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

##### 20.[杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

```Java
class Solution {
    ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();
    public List<List<Integer>> generate(int numRows) {
        ArrayList<Integer> temp=null;
        for (int i = 1; i <=numRows; i++) {
            ArrayList<Integer> now = new ArrayList<>();
            for (int j = 0; j <i; j++) {
                if (j==0||j==i-1){
                    now.add(1);
                }else{
                    now.add(temp.get(j-1)+temp.get(j));
                }
            }
            temp=now;
            res.add(now);
        }
        return res;
    }
}

```

##### 21.[打家劫舍](https://leetcode.cn/problems/house-robber/)

dp[i]=Math.max(dp[i-2],dp[i-3])+nums[i]

##### 22.[不同路径](https://leetcode.cn/problems/unique-paths/)

##### 23.[最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

##### 24.[只出现一次的数字](https://leetcode.cn/problems/single-number/)

异或运算满足交换律，a^b^a=a^a^b=b
