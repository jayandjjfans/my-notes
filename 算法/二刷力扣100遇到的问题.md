# 二刷力扣100遇到的问题

##### 最长不重复字串

更新left位置时，写成了**left=map.get(s.charAt(i))+1;**

实际上**start=Math.max(start,map.get(s.charAt(i))+1);**

忽略了当map中存在某char时，可能left已经跳过了它对应的位置。

##### 反转链表

需要经常熟悉，很久不写容易忘记简洁的写法

##### 最长回文子串

一开始没想起来该怎么写双层循环和dp怎么定义

```java
        //定义dp[i][j]
        for (int i = s.length()-1; i >=0; i--) {
            for (int j = i; j <s.length(); j++) {
            }
        }
```

##### 全排列

需要额外定义一个boolean[]来记录该位置是否被使用

##### 有效的括号

栈有关的API需要记忆

```java
Stack<Character> stack = new Stack<>();
stack.peek()；
stack.pop();
stack.push(s.charAt(i));
```

##### 旋转图像

之前没做过，所以要多熟悉

##### 删除链表的倒数第N个结点

链表题目中经常使用虚拟头节点来处理，尤其是涉及到头节点时

##### 只出现一次的数字

此题使用^运算符解决，但是注意初始res赋值为0而不是1

##### 验证二叉搜索树

新写出一种方法，不需要用列表保存遍历过程中的节点值，而是一边遍历一边比较，随时中断遍历返回false

##### 二叉树的层序遍历

需要多写，否则有些API可能就不知道怎么用了。

```java

LinkedList<TreeNode> temp = new LinkedList<>();
..........
TreeNode node = temp.remove();

```

##### 最长连续序列

第二次遍历时，遍历已经保存全部数据的set而不是原数组，去重后效率高

##### 二叉树展开为链表

之前自己做出来过，所以就没怎么关注。再做居然连曾经自己做出来的代码都看不懂，说明并不简单

##### 合并区间

要常练习，有些API用的比较少容易忘

##### 字母异位词分组

要常练习，有些API用的比较少容易忘

##### 打家劫舍

```Java
dp[i]=Math.max(dp[i-2],dp[i-3])+nums[i]  正确
dp[i]=dp[i-2]+nums[i]                    错误
```

##### LRU缓存

需要构造双向链表（定义Node对象(key, value,pre,next)）和哈希表（key:key, value:Node）

##### 回文链表

如果用反转链表的方式解答，不算得是简单题。做题时还是对反转链表不熟悉，需要常做。

##### 课程表

需要用到LinkedList   list.pop()

##### 数组中的第K个最大元素

快排有点难，当天没时间搞定，等有空一定搞清楚

##### 搜索插入位置

稍微卡顿了一下，要注意一些细节

##### K 个一组翻转链表

快指针走到K位置处，需要提前把K.next保存下来再反转，否则会形成环

##### 在排序数组中查找元素的第一个和最后一个位置

这道题还是得经常做，常思考，有些细节要注意

##### 腐烂的橘子

曾经自己写出过更好的代码，可以复习一下。

##### 最小栈

**第一次做**，用两个栈，一个辅助栈维护一个不严格的单调递减序列。

细节点是：min_stack.isEmpty()||val<=min_stack.peek()    不要漏掉等于号

##### 排序链表

切记此处fast不能赋值为head！！！否则当链表为两个节点时就无法拆分开

ListNode fast=head.next;

##### 每日温度

此题第一反应是使用栈（Stack）的数据结构解决。但是历史提交记录里使用ArrayDeque发现效率更高，也是使用栈的思想。查询得知：它**不是线程安全**的，因此没有同步开销，在单线程环境（如 LeetCode）中性能更优。注意学习相关API

##### 最长有效括号

虽然做出来了，但代码不够简洁。多参考自己整理的答案

##### N 皇后

第一次做，要常熟悉。

##### 分割等和子集 

每次基本上都能凭对该题思路的记忆做出来，但总觉得理解不够深刻。

##### 数据流的中位数

第一次做，理解并记得技巧的话并不难。注意堆的API  

```java
//此处需要逆序排列，注意初始化方法
small = new PriorityQueue<Integer>((x, y) -> (y - x));
......
//返回值是double类型，所以注意除以2.0
return small.size()==big.size()?(small.peek()+big.peek())/2.0:big.peek();

big.poll()
big.add()
big.poll()
```

##### 实现 Trie (前缀树)

第一次做，通过想象这个数据结构来理解这道题；其次是记住这道题如何定义节点和初始化

```java
class Trie {
    Trie[] child;
    boolean isEnd;

    public Trie() {
      //...........
    }
    public void insert(String word) {
      Trie node=this;
     //............
    }

    public boolean search(String word) {
     //.............
    }

    public boolean startsWith(String prefix) {
     //.............
    }
    //这个方法是新定义的，上面两个读方法都依赖
    public Trie searchPre(String str){
        Trie node=this;
     //.............
}
```

##### 寻找旋转排序数组中的最小值

标记为五星！之前做过，这次还是做不出来，这道题太难了。但是也不难，只需要也***<u>必须</u>***通过比较nums[mid]和nums[r]大小来缩小查找范围，和nums[l]比较没意义。并且在更新r时，r=mid(而不是mid-1)

##### 最长公共子序列

```java
if (text1.charAt(i-1)!=text2.charAt(j-1))
dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j])
```

##### 搜索旋转排序数组

此题基本上做不出来，此次是第一次梳理逻辑并整理参考代码：

1. 升序曲线图情况一共有四种，1左长右短、2左短右长、3左右相等、4全局升序
2. 通过比较nums[0] 和nums[mid]的大小关系，可以先将前三种情况和最后一种区分开
3. 对于nums[0] <= nums[mid]，可通过target是否在left和mid之间再次区分；对于nums[0] > nums[mid]，可通过target是否在mid和right之间再次区分

##### 字符串解码

之前曾经费劲写出来过，现在重新做还是需要很长时间。建议经常复习，尤其是相关API

##### 分割回文串 

注意：str.substring(start，end)方法，end超出索引范围一个值不会发生异常
